<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-08-11 Sat 20:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>S-SQL and Postgresql Arrays</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="style.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">S-SQL and Postgresql Arrays</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8badcae">Summary</a></li>
<li><a href="#orgab17c47">Use cases for arrays in a database</a>
<ul>
<li><a href="#orgbf00f02">General Usage</a></li>
<li><a href="#org8df60c6">Rules of Thumb - Do Not Use Arrays If:</a></li>
<li><a href="#org04acab9">Data Type Enforcement</a></li>
<li><a href="#orge869c5a">Indices on Arrays</a></li>
</ul>
</li>
<li><a href="#orgf62209b">S-SQL Array Support</a>
<ul>
<li><a href="#org8b7729f">:array (used inside a query calling a subquery, selecting into an array)</a></li>
<li><a href="#org9366e82">:array[] (declares an array and returns an array</a></li>
<li><a href="#org45520c9">:[] (used when you want a slice of an array</a></li>
<li><a href="#orgaaf3cdd">General Usage Examples</a></li>
</ul>
</li>
<li><a href="#org6eb82ac">Array Operators</a>
<ul>
<li><a href="#org9131bb5">Array Comparison Operators</a>
<ul>
<li><a href="#org2a6110c">:= Equality Comparison (Are two arrays equal on an element by element basis)</a></li>
<li><a href="#org514acd1">:&lt;&gt; Not Equal Comparison</a></li>
<li><a href="#orgb438996">:&lt; Less Than Comparison</a></li>
<li><a href="#org66cf38f">:&gt; Greater Than Comparison</a></li>
<li><a href="#org7f56729">:&gt;= Greater Than or Equal to Comparison</a></li>
<li><a href="#org4822268">:&lt;= Less Than or Equal To Comparison</a></li>
<li><a href="#org6a67b0a">:@&gt; Contains Comparison</a></li>
<li><a href="#org283336e">:&lt;@ Is Contained By Comparison</a></li>
<li><a href="#orgb9327a5">:&amp;&amp; Has Elements in Common Comparison</a></li>
</ul>
</li>
<li><a href="#org4030d97">Array Concatenation Operators</a>
<ul>
<li><a href="#orgb207924">:|| Concatentation Arrays and Elements</a></li>
<li><a href="#org52c6b59">:|| Concatenation with Multi-Dimensional Arrays</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4a9173c">Array functions</a>
<ul>
<li>
<ul>
<li><a href="#org373c8c0">Array-prepend</a></li>
<li><a href="#org98d6628">array-append</a></li>
<li><a href="#orga059b03">array-cat</a></li>
<li><a href="#orgb5f8ece">array-ndims</a></li>
<li><a href="#org4384e7a">array-dims</a></li>
<li><a href="#orgb81a077">array-fill</a></li>
<li><a href="#org05b7dab">array-length</a></li>
<li><a href="#orgdc06857">array-lower</a></li>
<li><a href="#org6a77b96">array-position</a></li>
<li><a href="#org923d8a5">array-positions</a></li>
<li><a href="#orge16b228">array-remove</a></li>
<li><a href="#org93c711f">array-replace</a></li>
<li><a href="#org721575b">array-to-string</a></li>
<li><a href="#orgeba8cd2">array-upper</a></li>
<li><a href="#org9e2f854">cardinality</a></li>
<li><a href="#orgf1d4446">string-to-array</a></li>
<li><a href="#org793af9e">unnest</a></li>
<li><a href="#org3496660">array-agg</a></li>
</ul>
</li>
<li><a href="#org6a1990e">NULL and nil</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="s-sql.html">Return to s-sql.html</a>
</p>
<div id="outline-container-org8badcae" class="outline-2">
<h2 id="org8badcae">Summary</h2>
<div class="outline-text-2" id="text-org8badcae">
<p>
Postmodern/s-sql can be used to insert ommon lisp arrays into postgresql databases,
pull postgresql database arrays out of databases into a common lisp array,
and generally engage in all the ways that sql can use postgresql arrays.
Postgresql arrays are documented at <a href="https://www.postgresql.org/docs/current/static/arrays.html">https://www.postgresql.org/docs/current/static/arrays.html</a>
and <a href="https://www.postgresql.org/docs/current/static/functions-array.html">https://www.postgresql.org/docs/current/static/functions-array.html</a>.
</p>

<p>
This page will go into more detail on how to use the available operators and functions
in s-sql.
</p>
</div>
</div>

<div id="outline-container-orgab17c47" class="outline-2">
<h2 id="orgab17c47">Use cases for arrays in a database</h2>
<div class="outline-text-2" id="text-orgab17c47">
</div>
<div id="outline-container-orgbf00f02" class="outline-3">
<h3 id="orgbf00f02">General Usage</h3>
<div class="outline-text-3" id="text-orgbf00f02">
<p>
Arrays are a first class datatype within postgresql. The contents can only be of a single
datatype and postgresql will enforce that typing. You can either use arrays as a datatype
stored in the database or there may be reasons why you want to use them as an intermediate
datatype in a query.
</p>

<p>
There is a bit of controversy over the use of the array datatype in a database. There are those
who adamantly oppose it, claiming that it is a violation of 1NF form (normalization).
It is easy to use arrays for the wrong reason in a database and there can be other
consequences which need to be taken into consideration - loss of referential integrity,
updating one slot in the array will require re-reading the entire array, and some other
lost search flexibility immediately come to mind. Like any design process decision, there
are reasons when you should design a database that is fully normalized
and use cases when denormalization can lead to speed and memory savings. You can read
some of the points at  <a href="https://news.ycombinator.com/item?id=4415754">https://news.ycombinator.com/item?id=4415754</a>. Another article
suggests that yould should not use arrays if you are going to have to keep accessing
items in the array by position for types that are variable in length
(hstores, jsonb, varchars, text). In such a case postgresql has to scan the array to
find the nth element because it stores variable length items as arrays of values,
not as an array of pointers to values. The article does not discuss using GIN indexes
on the array. It does suggest using the postgresql unnest sql function to resolve
some of these issues since it parses an array and returns a set of sets of entries
(one entry per row (the subset) and the total as the superset. An example of using
unnest in s-sql is set out below.
</p>

<p>
I would agree with Dimitri Fontaine who points out that "arrays can be used to denormalize data
and avoid lookup tables. A good rule of thumb for using them is you mostly use the array as a
whole, even if you might at times search for elements in the array." As he notes, "..heavier
processing is going to be more complex than a lookup table."
<a href="https://tapoueh.org/blog/2018/04/postgresql-data-types-arrays/">https://tapoueh.org/blog/2018/04/postgresql-data-types-arrays/</a>
</p>

<p>
Another way of saying it is to use arrays if you are storing "lists" of things, not if you are
storing lists of "things".
</p>

<p>
It really depends on your use case. If you need speed and very simple lookups, then arrays might
be what you want because your physical storage looking at fewer table pages. If it is not a really
simple lookup, use many-to-many tables because the lookup will take more time with an array than
the physical storage seeking cost.
</p>

<p>
At the same time, do not forget that you can use postgresql arrays in an intermediate
step in a query or as the result of the query. They can be used in ways other than
database table storage.
</p>

<p>
The postgresql documentation provides an employee pay example where the pay-by-quarter is a
one-dimensional array and the schedule is a two dimensional array.
</p>
<div class="org-src-container">
<pre class="src src-sql">CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);
</pre>
</div>


<p>
I have seen suggestions that arrays can replace separate many-to-many tables in
relationships, e.g.
</p>
<div class="org-src-container">
<pre class="src src-sql">CREATE TABLE posts (
    title TEXT,
    tags TEXT[]
);

-- Select all posts with tag 'kitty'
SELECT * FROM posts WHERE tags @&gt; '{kitty}';
</pre>
</div>
<p>
THIS IS NOT THE SAME AS PUTTING FOREIGN KEYS INTO THE ARRAY! DO NOT DO THAT!
Part of the reason for using an <a href="https://www.essentialsql.com/what-is-meant-by-acid/">ACID</a> database is to ensure integrity and putting
foreign keys into an array prevents the database from enforcing the integrity of
the foreign keys.
</p>

<p>
One very interesting write-up took a slightly different approach. Instead of
putting the one-to-many relationship directly in the posts table, it replaced
a many-to-many table (linking a document table with a tag table)
with a tags-array table (linking to the document table) and compared the size
and speed metrics with the normal m-t-m table. See:
</p>

<p>
<a href="http://www.databasesoup.com/2015/01/tag-all-things.html">http://www.databasesoup.com/2015/01/tag-all-things.html</a>,
<a href="http://www.databasesoup.com/2015/01/tag-all-things-part-2.html">http://www.databasesoup.com/2015/01/tag-all-things-part-2.html</a>,
<a href="http://www.databasesoup.com/2015/01/tag-all-things-part-3.html">http://www.databasesoup.com/2015/01/tag-all-things-part-3.html</a>
</p>

<p>
In this case, it found searching for documents using the tag array approach to be much faster
than the normal normalized approach, as well as having a smaller storage size.
</p>

<p>
The s-sql version for creating the table currently requires a separate create table and
two separate create index commands
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:create-table documents
                      ((doc-id :type integer :constraint 'dockey-id :primary-key 't :unique)
                       (text :type text))))

(query (:create-table doc-tags-array ((doc-id :type integer :references ((documents doc-id)))
                                      (tags :type text[] :default "{}"))))


(query (:create-unique-index 'doc-tags-id-doc-id :on "doc-tags-array"  :fields 'doc-id))

(query (:create-index 'doc-tags-id-tags :on "doc-tags-array" :using gin :fields 'tags))

</pre>
</div>
<p>
And then the corresponding searches for one tag and two (or more) tags would be:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:limit
        (:order-by
         (:select 'doc-id
                  :from 'doc-tags-array
                  :where (:@&gt; 'tags (:array[] "math")))
         'doc-id)
        25 0))

(query (:limit
        (:order-by
         (:select 'doc-id
                  :from 'doc-tags-array
                  :where (:@&gt; 'tags (:array[] "math" "physics")))
         'doc-id)
        25))

</pre>
</div>

<p>
Note that is was a one-to-many relationship. If you need a
many-to-many (mtm or m-t-m) relationship, you would need two sets of arrays.
</p>

<p>
A similar approach was examined in
 <a href="https://medium.com/@leshchuk/mtm-on-arrays-in-postgresql-a97f3c50b8c6">https://medium.com/@leshchuk/mtm-on-arrays-in-postgresql-a97f3c50b8c6</a>
which concluded that if you do not need referential integrity in the
one-to-many or many-to-many relationship, the array length is in
the tens rather than hundreds or thousands, and you use a GIN index,
there is a speed and memory benefit to using an array to contain
the relationship ids compared to a mtm table. This is particularly
the case if the relations are disproportionate - e.g. 1 million
documents and 100 tags. In those tests, the cost of joins exceeded
the indexed access speed of using arrays.
</p>

<p>
One use case is to reduce the number of columns in a table
where you are using the array as an atomic data unit.  If you
discover that you are doing a lot of searches and joins on
array slots, this is likely to be a bad design.
</p>

<p>
Another use case is to store machine learning model weights which
are a 2d array of numbers.
</p>

<p>
The <a href="https://madlib.apache.org/">MADlib</a> advanced statistical and machine learning addon extension
for <a href="https://www.postgresql.org">postgresql</a> and <a href="https://greenplum.org/">greenplum</a> uses arrays for intputs into its algorithms.
</p>

<p>
Sidenote: The greenplum massively parallel database project is a
fork from postgresql and is a bit behind on the standard postgresql
functionality.
</p>

<p>
In any case, s-sql may have available calls to postgresql functions
which are not in the database version you are programming to.
</p>

<p>
See also <a href="https://www.compose.com/articles/take-a-dip-into-postgresql-arrays/">https://www.compose.com/articles/take-a-dip-into-postgresql-arrays/</a>
</p>
</div>
</div>

<div id="outline-container-org8df60c6" class="outline-3">
<h3 id="org8df60c6">Rules of Thumb - Do Not Use Arrays If:</h3>
<div class="outline-text-3" id="text-org8df60c6">
<ul class="org-ul">
<li>Do not use arrays where you need to maintain integrity for foreign relationships. That is what</li>
</ul>
<p>
foreign keys are for.
</p>

<ul class="org-ul">
<li>Do not use arrays if you have to change the items in the array frequently.</li>

<li>Do not use arrays if you rely on an ORM unless you have ensured</li>
</ul>
<p>
that the ORM can utilize arrays.
</p>
</div>
</div>



<div id="outline-container-org04acab9" class="outline-3">
<h3 id="org04acab9">Data Type Enforcement</h3>
<div class="outline-text-3" id="text-org04acab9">
<p>
Compared to jsonb, postgresql arrays allow you to enforce
the data type. This can be critical in both maintaining
the integrity of your data as well as optimization
in your appliction code. This database enforeced type
safety does not, however, enforce the dimensionality
of the array.
</p>
</div>
</div>

<div id="outline-container-orge869c5a" class="outline-3">
<h3 id="orge869c5a">Indices on Arrays</h3>
<div class="outline-text-3" id="text-orge869c5a">
<p>
It is highly recommended that you use GIN or GIST indexes to search
for items in array column. You should remember that GIST indices are
lossy while GIN indices are lossless.
</p>
</div>
</div>
</div>


<div id="outline-container-orgf62209b" class="outline-2">
<h2 id="orgf62209b">S-SQL Array Support</h2>
<div class="outline-text-2" id="text-orgf62209b">
<p>
S-sql can feel a little messy with respect to arrays but that
is in large part because (a) sql dealing with arrays is messy and
(b) postgresql has both an array[] constructor and an array function.
</p>

<p>
If you are just translating between a lisp array and a
postgresql array, then postmodern handles the data type translation
fairly easily as can be seen in the examples below.
</p>

<p>
Generally speaking, there are three base s-sql array operators
to know:
</p>
</div>

<div id="outline-container-org8b7729f" class="outline-3">
<h3 id="org8b7729f">:array (used inside a query calling a subquery, selecting into an array)</h3>
<div class="outline-text-3" id="text-org8b7729f">
<p>
The format of the call is:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(:array (query))
</pre>
</div>
<p>
Example:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:order-by
        (:select 'r.rolename
                 (:as (:array
                       (:select 'b.rolename
                                :from (:as 'pg_catalog.pg-auth-members 'm)
                                :inner-join (:as 'pg-catalog.pg-roles 'b)
                                :on (:= 'm.roleid 'b.oid)
                                :where (:= 'm.member 'r.oid )))
                      'memberof)
                 :from (:as 'pg-catalog.pg-roles 'r))
        1))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9366e82" class="outline-3">
<h3 id="org9366e82">:array[] (declares an array and returns an array</h3>
<div class="outline-text-3" id="text-org9366e82">
<p>
The format of the call is:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(:array[] (&amp;rest args))
</pre>
</div>
<p>
Examples:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array[] 2 6))
       :single)
#(2 6)

(query (:select (:array[] (:/ 15 3) (:pi) 6))
       :single)

#(5.0d0 3.141592653589793d0 6.0d0)
</pre>
</div>
<p>
Note that in the second example, the value of 6 is returned as a
float because the entire array must be the same type.
</p>
</div>
</div>

<div id="outline-container-org45520c9" class="outline-3">
<h3 id="org45520c9">:[] (used when you want a slice of an array</h3>
<div class="outline-text-3" id="text-org45520c9">
<p>
The format of the call is:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(:[] (form start &amp;optional end))
</pre>
</div>
<p>
Example:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((arry1 #(2 6 7 12)))
     (query (:select (:[] arry1 2 3))
            :single))

#(6 7)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgaaf3cdd" class="outline-3">
<h3 id="orgaaf3cdd">General Usage Examples</h3>
<div class="outline-text-3" id="text-orgaaf3cdd">
<p>
Just to make these usage examples really simple, we will use the
simplest use case version discussed above, with a tags array in a table
with the name of the item. In this case the name is the name of a
receipe and the tags are ingredients that either go in the receipe
or accompany the receipe.
</p>

<p>
First to create the table and the indexes. The index on 'name is the
default B-tree index. The index on the tags is a GIN index.
</p>

<div class="org-src-container">
<pre class="src src-sql">(query (:create-table receipes
                       ((name :type text)
                        (tags :type text[] :default "{}"))))

(query (:create-unique-index 'receipe-tags-id-name
                              :on "receipes"
                              :fields 'name))

(query (:create-index 'receipe-tags-id-tags
                       :on "receipes"
                       :using gin
                       :fields 'tags))
</pre>
</div>
<p>
Now use :insert-rows-into to populate the table. Notice we are actually
passing in lisp arrays and it is automatically inserted in the table
as a postgresql array.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:insert-rows-into
        'receipes
        :columns 'name 'tags
        :values
        '(("Fattoush" #("greens" "pita bread" "olive oil" "garlic" "lemon" "salt" "spices"))
          ("Shawarma" #("meat" "tahini sauce" "pita bread"))
          ("Baba Ghanoush" #("pita bread" "olive oil" "eggplant" "tahini sauce"))
          ("Shish Taouk" #("chicken" "lemon juice" "garlic" "paprika" "yogurt" "tomato paste" "pita bread"))
          ("Kibbe nayeh" #("raw meat" "bulgur" "onion" "spices" "pita bread"))
          ("Manakeesh" #("meat" "cheese" "zaatar" "kishik" "tomatoes" "cucumbers" "mint leaves" "olives"))
          ("Fakafek" #("chickpeas" "pita bread" "tahini sauce"))
          ("Tabbouleh" #("bulgur" "tomatoes" "onions" "parsley"))
          ("Kofta" #("minced meat" "parsley" "spices" "onions"))
          ("Kunafeh" #("cheese" "sugar syrup" "pistachios"))
          ("Baklava" #("filo dough" "honey" "nuts")))))
</pre>
</div>


<p>
This will automatically insert the required square brackets into the sql statement
being passed to postgresql. This automatic translation between lisp and
postgresql arrays does not work where you need a postgresql function in a query.
(The database function is not going to be in a lisp array.)
For that you need to use the :array[] sql-op. E.g.
</p>

<p>
Sample desired sql statement:
</p>
<div class="org-src-container">
<pre class="src src-sql">(SELECT ARRAY[(1 / 2)]::FLOATS[]);
</pre>
</div>
<p>
S-sql version
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:type (:array[] (:/ 1 2)) float[])))
</pre>
</div>

<p>
First we can start by checking for records that have a specific tag
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select 'receipe-id 'tags
                :from 'receipe-tags-array
                :where (:@&gt; 'tags
                            (:array[] "bulgur"))))
(("Tabbouleh" #("bulgur" "tomatoes" "onions" "parsley"))
 ("Kibbe nayeh" #("raw meat" "bulgur" "onions" "spices" "pita bread")))

</pre>
</div>
<p>
We should look at this return a bit closer. As you might expect in postmodern,
this query returns list of lists and each sublist contains the string name.
What may be unexpected is that the second item in each sublist is actually
a lisp array.
</p>

<p>
Extending this to checking for items with two specific tags:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select 'receipe-id 'tags
                :from 'receipe-tags-array
                :where (:@&gt; 'tags
                            (:array[] "bulgur" "parsley"))))

(("Tabbouleh" #("bulgur" "tomatoes" "onions" "parsley")))
</pre>
</div>
<p>
As you should expect, we can also pass in a lisp variable which
is an array, in this case we are using the :&amp;&amp; operator which
acts as an 'or' logical test:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((tst-arry #("parsley" "cheese")))
  (query (:order-by (:select '*
                             :from 'receipes
                             :where (:&amp;&amp; 'tags tst-arry))
                    'name)))
'(("Manakeesh"
   #("meat" "cheese" "zaatar" "kishik" "tomatoes" "cucumbers" "mint leaves"
     "olives"))
  ("Tabbouleh" #("bulgur" "tomatoes" "onions" "parsley"))
  ("Kofta" #("minced meat" "parsley" "spices" "onions"))
  ("Kunafeh" #("cheese" "sugar syrup" "pistachios")))

</pre>
</div>


<p>
Validating that this is returning a vector:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(type-of (query (:select 'tags
                         :from 'receipes
                         :where (:= 'name "Manakeesh"))
                :single))

'(SIMPLE-VECTOR 8)
</pre>
</div>
<p>
We can also check the length of the array or cardinality:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:cardinality 'tags)
                :from 'receipes
                :where (:= 'name "Manakeesh"))
       :single)
</pre>
</div>

<p>
Updating the array can be done either explicitly:
</p>
<div class="org-src-container">
<pre class="src src-lisp">;;; Update array with an lisp array (changing onion to onions in the one row where it is singular
(query (:update 'receipes
                :set 'tags #("raw meat" "bulgur" "onions" "spices" "pita bread")
                :where (:= 'name "Kibbe nayeh")))
</pre>
</div>
<p>
or passing in a lisp variable:
</p>
<div class="org-src-container">
<pre class="src src-lisp">;;; checking passing a lisp array as a variable
(let ((lisp-arry #("wine" "garlic" "soy sauce")))
  (query (:update 'receipes
                  :set 'tags '$1
                  :where (:= 'name 11))
         lisp-arry))
</pre>
</div>

<p>
If you are selecting a slice of a postgresql array, then use :[].
At this point it is a good reminder that postgresql arrays start
at 1, not at 0. The first parameter following the field name is
the starting point of the slice to return. The second parameter
is the end point of the slice to return (defaulting to the
starting point).
</p>

<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:[] 'tags 2)
                :from 'receipes
                :where (:= 'name 3)))

'(("olive oil"))

(query (:select (:[] 'tags 2 3)
                :from 'receipes
                :where (:= 'name 3)))

'((#("olive oil" "eggplant")))

</pre>
</div>
<p>
If you are sub-selecting into a postgresql array, postgresql switches
from square brackets to parens, so in s-sql you need to
use :array. E.g.
</p>

<p>
Sample desired sql statement:
</p>
<div class="org-src-container">
<pre class="src src-sql">
SELECT r.rolname,
  ARRAY(SELECT b.rolname
        FROM pg_catalog.pg_auth_members m
        JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
        WHERE m.member = r.oid) as memberof
FROM pg_catalog.pg_roles r
ORDER BY 1;
**************************
</pre>
</div>

<p>
And now the s-sql version. Here, because we are selecting into an array,
we need to use just :array
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:order-by
        (:select 'r.rolename
                 (:as (:array
                       (:select 'b.rolename
                                :from (:as 'pg_catalog.pg-auth-members 'm)
                                :inner-join (:as 'pg-catalog.pg-roles 'b)
                                :on (:= 'm.roleid 'b.oid)
                                :where (:= 'm.member 'r.oid )))
                      'memberof)
                 :from (:as 'pg-catalog.pg-roles 'r))
        1))
</pre>
</div>

<p>
The postgresql unnest function (:unnest ..)  expands every
array entry into a separate row. In the following select, we pull out all
the distinct tags in a list of lists where every list has a single tag entry.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:order-by
        (:select (:as (:unnest 'tags) 'tag) :distinct
                 :from 'receipes)
        'tag))

'(("bulgur") ("cheese") ("chicken") ("chickpeas") ("cucumbers") ("eggplant")
  ("filo dough") ("garlic") ("greens") ("honey") ("kishik") ("lemon")
  ("lemon juice") ("meat") ("minced meat") ("mint leaves") ("nuts")
  ("olive oil") ("olives") ("onions") ("paprika") ("parsley")
  ("pistachios") ("pita bread") ("raw meat") ("salt") ("spices") ("sugar syrup")
  ("tahini sauce") ("tomatoes") ("tomato paste") ("yogurt") ("zaatar"))
</pre>
</div>

<p>
We can use with and group-by operators to count the unique tags:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:order-by
        (:with
         (:as 'p
              (:select (:as (:unnest 'tags) 'tag)
                       :from 'receipes))
         (:select 'tag (:as (:count 'tag) 'cnt)
                  :from 'p
                  :group-by 'tag))
        (:desc 'cnt) 'tag))
'(("pita bread" 6) ("onions" 3) ("spices" 3) ("tahini sauce" 3) ("bulgur" 2)
  ("cheese" 2) ("garlic" 2) ("meat" 2) ("olive oil" 2) ("parsley" 2)
  ("tomatoes" 2) ("chicken" 1) ("chickpeas" 1) ("cucumbers" 1) ("eggplant" 1)
  ("filo dough" 1) ("greens" 1) ("honey" 1) ("kishik" 1) ("lemon" 1)
  ("lemon juice" 1) ("minced meat" 1) ("mint leaves" 1) ("nuts" 1) ("olives" 1)
  ("paprika" 1) ("pistachios" 1) ("raw meat" 1) ("salt" 1) ("sugar syrup" 1)
  ("tomato paste" 1) ("yogurt" 1) ("zaatar" 1))
</pre>
</div>

<p>
Yes, there are array-append, array-replace etc operators
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:update 'receipes
                :set 'tags (:array-append 'tags "appended-items")
                :where (:= 'name "Kibbe nayeh")))

(query (:update 'receipes
                :set 'tags (:array-replace 'tags "spices" "chocolate")))
</pre>
</div>
<p>
The above two versions checked all the row, even those without the target string,
effectively the equivalent of not using the index.
</p>

<p>
You can use a different operator that more effectively uses the GIN index and
just touches the rows with the targeted string in the array:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:update 'receipes
                :set 'tags (:array-replace 'tags  "chocolate" "spices")
                :where (:&lt;@ "{\"chocolate\"}" 'tags)))
</pre>
</div>

<p>
The use of the :any* operator needs to be considered as a special case. Quoting
Marijn Haverbeke here,"Postgres has both a function-call-style any and an infix any,
and S-SQL's syntax doesn't allow them to be distinguished." As a result, s-sql
has a regular :any sql-op and a :any* sql-op, which expand slightly differently.
</p>

<p>
To show the difference, look at the sql statements that are generated by the two
operators :any* and :any
</p>
<div class="org-src-container">
<pre class="src src-lisp">(sql (:select '*
                :from 'receipes
                :where (:= "chicken" (:any* 'tags ))))

"(SELECT * FROM receipes WHERE (E'chicken' = ANY(tags)))"

(sql (:select '*
                :from 'receipes
                :where (:= "chicken" (:any 'tags ))))

"(SELECT * FROM receipes WHERE (E'chicken' = ANY tags))"
</pre>
</div>

<p>
In the following two cases we want to use ':any*'. In the first simple query,
we are looking for everything in the rows where the name of the receipe is in
the lisp array we passed in.
</p>

<p>
In the second query we look for all the rows where the string "chicken"
appears in any of the tag arrays.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select '*
                :from 'receipes
                :where (:= 'name (:any* '$1)))
       #("Trout" "Shish Taouk" "Hamburger"))

'(("Shish Taouk"
   #("chicken" "lemon juice" "garlic" "paprika" "yogurt" "tomato paste"
     "pita bread")))

(query (:select '*
                :from 'receipes
                :where (:= '$1 (:any* 'tags )))
       "chicken")

'(("Shish Taouk"
   #("chicken" "lemon juice" "garlic" "paprika" "yogurt" "tomato paste"
     "pita bread")))
</pre>
</div>

<p>
We can look for rows where x or y is found in the tags array. This uses
the or operator which looks like :&amp;&amp;.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:order-by
        (:select '*
                 :from 'receipes
                 :where (:&amp;&amp; 'tags (:array[] '$1 '$2)))
        'name)
       "parsley" "cheese")
'(("Manakeesh"
   #("meat" "cheese" "zaatar" "kishik" "tomatoes" "cucumbers" "mint leaves"
     "olives"))
  ("Tabbouleh" #("bulgur" "tomatoes" "onions" "parsley"))
  ("Kofta" #("minced meat" "parsley" "spices" "onions"))
  ("Kunafeh" #("cheese" "sugar syrup" "pistachios")))
</pre>
</div>

<p>
There are also specific operators for "contains" (:@&gt;) and "contained-by" (:&lt;@).
This comparison is done on an element by element basis, so is easily
thought of as whether the elements in array1 are a subset of the elements
in array2 or vice versa.
</p>

<p>
The following examples should be easy to follow.
</p>

<p>
In the first example we are looking for rows where the elements of an
array composed of the two strings passed in as parameters is contained
by the row in the database.
</p>

<p>
In the second example, we have flipped the parameters and operator around.
We are looking for rows from the database table which contain the elements
of an array composed of the two strings passed in as parameters.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:order-by
        (:select '* :from 'receipes
                 :where (:&lt;@ (:array[] '$1 '$2)
                             'tags))
        'name)
       "tomatoes" "cheese")

'(("Manakeesh"
   #("meat" "cheese" "zaatar" "kishik" "tomatoes" "cucumbers" "mint leaves"
     "olives")))

(query (:order-by
        (:select '* :from 'receipes
                 :where (:@&gt; 'tags
                             (:array[] '$1 '$2)))
        'name)
       "tomatoes" "cheese")

'(("Manakeesh"
   #("meat" "cheese" "zaatar" "kishik" "tomatoes" "cucumbers" "mint leaves"
     "olives")))
</pre>
</div>
<p>
In the following two examples, we do something similar, but we are looking
to see if the tags array in any row in the database table is a subset of
the small two element array we are passing in. The answer is nil.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(query (:order-by
        (:select '* :from 'receipes
                 :where (:@&gt; (:array[] '$1 '$2)
                             'tags))
        'name)
       "tomatoes" "cheese")

nil

(query (:order-by
        (:select '* :from 'receipes
                 :where (:&lt;@ 'tags
                             (:array[] '$1 '$2)))
        'name)
       "tomatoes" "cheese")

nil
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6eb82ac" class="outline-2">
<h2 id="org6eb82ac">Array Operators</h2>
<div class="outline-text-2" id="text-org6eb82ac">
</div>
<div id="outline-container-org9131bb5" class="outline-3">
<h3 id="org9131bb5">Array Comparison Operators</h3>
<div class="outline-text-3" id="text-org9131bb5">
<p>
Per postgresql <a href="https://www.postgresql.org/docs/current/static/functions-array.html">documentation</a> array comparisons compare the array contents
element-by-element,  using the default B-tree comparison function for the
element data type. In multidimensional arrays the elements are visited in
row-major order (last subscript varies most rapidly). If the contents of
two arrays are equal but the dimensionality is different, the first
difference in the dimensionality information determines the sort order.
</p>

<p>
Form is (:operator array1 array2)
</p>
</div>
<div id="outline-container-org2a6110c" class="outline-4">
<h4 id="org2a6110c">:= Equality Comparison (Are two arrays equal on an element by element basis)</h4>
<div class="outline-text-4" id="text-org2a6110c">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:= (:array[] 1 2 3) (:array[] 1 2 3)))
       :single)
T

(query (:select (:= (:array[] "a" "b" "c") (:array[] "a" "b" "c")))
       :single)
T

(query (:select (:= (:type (:array[] 1 2 3) integer[]) (:array[] 1 2 3)))
       :single)
T

(query (:select (:= (:array[] 1 2 3) (:array[] 1 4 3)))
       :single)
nil

(query (:select (:= (:type (:array[] 1 2 3) integer[]) (:array[] 1 2 3 5)))
       :single)

nil

(let ((arry1 #(1 2 3)) (arry2 #(1 2 3)))
  (query (:select (:= arry1 arry2))
         :single))
T
</pre>
</div>
</div>
</div>

<div id="outline-container-org514acd1" class="outline-4">
<h4 id="org514acd1">:&lt;&gt; Not Equal Comparison</h4>
<div class="outline-text-4" id="text-org514acd1">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:&lt;&gt; (:array[] 1 2 3) (:array[] 1 2 4)))
       :single)
T
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb438996" class="outline-4">
<h4 id="orgb438996">:&lt; Less Than Comparison</h4>
<div class="outline-text-4" id="text-orgb438996">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:&lt; (:array[] 1 2 3) (:array[] 1 2 4)))
       :single)
T
</pre>
</div>
</div>
</div>

<div id="outline-container-org66cf38f" class="outline-4">
<h4 id="org66cf38f">:&gt; Greater Than Comparison</h4>
<div class="outline-text-4" id="text-org66cf38f">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:&gt; (:array[] 1 4 3) (:array[] 1 2 4)))
       :single)
T
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f56729" class="outline-4">
<h4 id="org7f56729">:&gt;= Greater Than or Equal to Comparison</h4>
<div class="outline-text-4" id="text-org7f56729">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:&gt;= (:array[] 1 4 3) (:array[] 1 4 3)))
       :single)
T
</pre>
</div>
</div>
</div>

<div id="outline-container-org4822268" class="outline-4">
<h4 id="org4822268">:&lt;= Less Than or Equal To Comparison</h4>
<div class="outline-text-4" id="text-org4822268">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:&lt;= (:array[] 1 2 3) (:array[] 1 2 3)))
       :single)
T
</pre>
</div>
</div>
</div>

<div id="outline-container-org6a67b0a" class="outline-4">
<h4 id="org6a67b0a">:@&gt; Contains Comparison</h4>
<div class="outline-text-4" id="text-org6a67b0a">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:@&gt; (:array[] 1 4 3) (:array[] 3 1)))
       :single)
T

(query (:select (:@&gt; (:array[] 1 4 73) (:array[] 3 0)))
       :single)
nil
</pre>
</div>
</div>
</div>
<div id="outline-container-org283336e" class="outline-4">
<h4 id="org283336e">:&lt;@ Is Contained By Comparison</h4>
<div class="outline-text-4" id="text-org283336e">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:&lt;@ (:array[] 2 7) (:array[] 1 7 4 2 6)))
        :single)
T

(query (:select (:&lt;@ (:array[] 1 4 3) (:array[] 3 1)))
       :single)
nil
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb9327a5" class="outline-4">
<h4 id="orgb9327a5">:&amp;&amp; Has Elements in Common Comparison</h4>
<div class="outline-text-4" id="text-orgb9327a5">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:&amp;&amp; (:array[] 1 4 3) (:array[] 3 1)))
       :single)
T
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4030d97" class="outline-3">
<h3 id="org4030d97">Array Concatenation Operators</h3>
<div class="outline-text-3" id="text-org4030d97">
<p>
Form (:|| item1 item2 &#x2026;)
</p>
</div>
<div id="outline-container-orgb207924" class="outline-4">
<h4 id="orgb207924">:|| Concatentation Arrays and Elements</h4>
<div class="outline-text-4" id="text-orgb207924">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:|| 3 (:array[] 4 5 6)))
       :single)

#(3 4 5 6)

(query (:select (:|| (:array[] 4 5 6) 7))
       :single)

#(4 5 6 7)

(query (:select (:|| (:array[] 1 2) (:array[] 3 4)))
       :single)

#(1 2 3 4)

(query (:select (:|| 1 (:type "[0:1]={2,3}" int[])))
       :single)

#(1 2 3)

(query (:select (:|| 3 (:array[] 4 5 6) (:array[] 7 8 9) 10))
       :single)
#(3 4 5 6 7 8 9 10)
</pre>
</div>
</div>
</div>

<div id="outline-container-org52c6b59" class="outline-4">
<h4 id="org52c6b59">:|| Concatenation with Multi-Dimensional Arrays</h4>
<div class="outline-text-4" id="text-org52c6b59">
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:|| (:array[] 1 2 3) (:array[] (:array[] 4 5 6) (:array[] 7 8 9))))
       :single)

#2A((1 2 3) (4 5 6) (7 8 9))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org4a9173c" class="outline-2">
<h2 id="org4a9173c">Array functions</h2>
<div class="outline-text-2" id="text-org4a9173c">
</div>
<div id="outline-container-org373c8c0" class="outline-4">
<h4 id="org373c8c0">Array-prepend</h4>
<div class="outline-text-4" id="text-org373c8c0">
<p>
Form: (:array-prepend (array1 element))
Appends an element to the beginning of an array
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-prepend 1 (:array[] 2 3)))
       :single)

#(1 2 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-org98d6628" class="outline-4">
<h4 id="org98d6628">array-append</h4>
<div class="outline-text-4" id="text-org98d6628">
<p>
Form: (:array-append (array1 element))
Appends an element to the end of an array.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-append (:array[] 4 5 6) 7))
       :single)

#(4 5 6 7)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga059b03" class="outline-4">
<h4 id="orga059b03">array-cat</h4>
<div class="outline-text-4" id="text-orga059b03">
<p>
Form: (:array-cat (array1 array2))
Concatenates two arrays. No more, no less. Both arrays need to have the same
data type. They do not need to be the same length.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-cat (:array[] 1 2) (:array[] 3 4)))
       :single)

#(1 2 3 4)

(query (:select (:array-cat (:array[] (:array[] 1 2) (:array[] 3 4)) (:array[] 5 6)))
       :single)

#2A((1 2) (3 4) (5 6))

(query (:select (:array-cat (:array[] 1 2) (:array[] 3 4 5)))
       :single)

#(1 2 3 4 5)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5f8ece" class="outline-4">
<h4 id="orgb5f8ece">array-ndims</h4>
<div class="outline-text-4" id="text-orgb5f8ece">
<p>
Form: (:array-ndims (array))
Array-ndims returns the number of dimensions of an array.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-ndims (:array[] (:array[] 1 2 3) (:array[] 4 5 6))))
       :single)
2
</pre>
</div>
</div>
</div>

<div id="outline-container-org4384e7a" class="outline-4">
<h4 id="org4384e7a">array-dims</h4>
<div class="outline-text-4" id="text-org4384e7a">
<p>
Form: (:array-dims (array1))
Array-dims returns a text representation of an array's dimensions.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-dims (:array[] (:array[] 1 2 3) (:array[] 4 5 6))))
       :single)
"[1:2][1:3]"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb81a077" class="outline-4">
<h4 id="orgb81a077">array-fill</h4>
<div class="outline-text-4" id="text-orgb81a077">
<p>
Form: (:array-fill (value array-dimension))
Array-fill returns an array initialized with supplied value and length.
This only works with one dimensional arrays
</p>
<div class="org-src-container">
<pre class="src src-lisp">
</pre>
</div>
<p>
(query (:select (:array-fill 7 (:array[] 3)))
       :single)
</p>

<p>
#(7 7 7)
</p>
</div>
</div>
<div id="outline-container-org05b7dab" class="outline-4">
<h4 id="org05b7dab">array-length</h4>
<div class="outline-text-4" id="text-org05b7dab">
<p>
Form: (:array-length (array1 array-dimension))
Returns the length of the requested array dimension.
In the following example, we request the first array
dimension.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-length (:array[] 1 2 3) 1 ))
       :single)
3

(query (:select (:array-length (:array[] #(#(1 2 3)#(4 5 6))) 1)) :single)

1

(query (:select (:array-length (:array[] #(#(1 2 3)#(4 5 6))) 2)) :single)

2
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc06857" class="outline-4">
<h4 id="orgdc06857">array-lower</h4>
<div class="outline-text-4" id="text-orgdc06857">
<p>
Form: (:array-lower (&amp;rest args))
Array-lower returns the lower bound of the requested array dimension.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-lower (:type "[0:2]={1,2,3}" integer[]) 1))
       :single)
0
</pre>
</div>
</div>
</div>

<div id="outline-container-org6a77b96" class="outline-4">
<h4 id="org6a77b96">array-position</h4>
<div class="outline-text-4" id="text-org6a77b96">
<p>
Form: (:array-position (array element starting-point-if-not-one))
Array-position returns the subscript of the first occurrence of the
second argument in the array, starting at the element indicated by the third
argument or at the first element. The array must be one-dimensional.
Requires postgresql version 9.5 or newer.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-position (:array[] "sun" "mon" "tue" "wed" "thu" "fri" "sat") "mon"))
       :single)
2
</pre>
</div>
</div>
</div>


<div id="outline-container-org923d8a5" class="outline-4">
<h4 id="org923d8a5">array-positions</h4>
<div class="outline-text-4" id="text-org923d8a5">
<p>
Form: (:array-positions (array element))
Array-positions (note the plural) returns an array of subscripts
of all occurrences of the second argument in the array given as
the first argument. The array must be one-dimensional.
Requires postgresql version 9.5 or newer.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-positions (:array[] "A" "A" "B" "A") "A"))
       :single)

#(1 2 4)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge16b228" class="outline-4">
<h4 id="orge16b228">array-remove</h4>
<div class="outline-text-4" id="text-orge16b228">
<p>
Form: (:array-remove (array element))
Array-remove removes all elements equal to the given value
from the array (array must be one-dimensional).
Requires postgresql 9.3 or newer.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-remove (:array[] "A" "A" "B" "A") "B"))
       :single)

#("A" "A" "A")
</pre>
</div>
<p>
Obviously inside a selection query array-remove only removes the elements
from the returning set and does not change the underlying data..
</p>
</div>
</div>

<div id="outline-container-org93c711f" class="outline-4">
<h4 id="org93c711f">array-replace</h4>
<div class="outline-text-4" id="text-org93c711f">
<p>
Form: (:array-replace (array element-to-be-replaced element-used-as-replacement))
Array-replaces replaces each array element equal to the given value
with a new value. Requires postgresql 9.3 or newer.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-replace (:array[] 1 2 5 4) 5 3))
       :single)

#(1 2 3 4)
</pre>
</div>
</div>
</div>

<div id="outline-container-org721575b" class="outline-4">
<h4 id="org721575b">array-to-string</h4>
<div class="outline-text-4" id="text-org721575b">
<p>
Form: (:array-to-string (array delimiter optional-null-string))
Array-to-string concatenates array elements using supplied
delimiter and optional null string.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-to-string (:array[] 1 2 3 :NULL 5) "," "*"))
       :single)

"1,2,3,*,5"
</pre>
</div>
</div>
</div>


<div id="outline-container-orgeba8cd2" class="outline-4">
<h4 id="orgeba8cd2">array-upper</h4>
<div class="outline-text-4" id="text-orgeba8cd2">
<p>
Form: (:array-upper (array int))
Array-upper returns upper bound of the requested array dimension.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-upper (:array[] 1 8 3 7) 1))
       :single)
4
</pre>
</div>
</div>
</div>

<div id="outline-container-org9e2f854" class="outline-4">
<h4 id="org9e2f854">cardinality</h4>
<div class="outline-text-4" id="text-org9e2f854">
<p>
Form: (:cardinality (array))
Returns the total number of elements in the array or 0 if
the array is empty. Requires postgresql 9.4 or newer.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-length (:array[] 1 2 3) 1 ))
       :single)
3
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf1d4446" class="outline-4">
<h4 id="orgf1d4446">string-to-array</h4>
<div class="outline-text-4" id="text-orgf1d4446">
<p>
Form: (:string-to-array (text delimiter optional-null-string))
String-to-array splits a string into array elements using
the supplied delimiter and optional null string.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:string-to-array "xx~^~yy~^~zz" "~^~" "yy"))
       :single)

#("xx" :NULL "zz")
</pre>
</div>
</div>
</div>

<div id="outline-container-org793af9e" class="outline-4">
<h4 id="org793af9e">unnest</h4>
<div class="outline-text-4" id="text-org793af9e">
<p>
Form: (:unnest (array))
Unnest expands an array to a set of rows.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:unnest (:array[] 1 2))))

'((1) (2))
</pre>
</div>
<p>
It is possible to call unnest with multiple arrays, but this is only
allowed in the from clause of the query. See
<a href="https://www.postgresql.org/docs/current/static/queries-table-expressions.html#QUERIES-TABLEFUNCTIONS">https://www.postgresql.org/docs/current/static/queries-table-expressions.html#QUERIES-TABLEFUNCTIONS</a>
</p>
</div>
</div>

<div id="outline-container-org3496660" class="outline-4">
<h4 id="org3496660">array-agg</h4>
<div class="outline-text-4" id="text-org3496660">
<p>
Form: (:array-agg (expression))
Array-agg returns the result in an array (both sql and, in postmodern, a lisp array).
</p>

<p>
Note the fourth example (available only in postgresql versions 9.4 or newer)
filters out null values.
</p>

<p>
Like all the aggregate functions, you can pass :filter, :distinct or :order-by
(in that order) as additional parameters.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(query (:select (:array-agg 'name) :from 'receipes) :single)

#("Fattoush" "Shawarma" "Baba Ghanoush" "Shish Taouk" "Kibbe nayeh" "Manakeesh"
  "Fakafek" "Tabbouleh" "Kofta" "Kunafeh" "Baklava")

(query (:select (:array-agg 'city :distinct)
        :from 'employee)
  :single)

#("New York" "Toronto" "Vancouver")

(query (:select (:array-agg 'city :distinct :order-by (:desc 'city))
        :from 'employee)
  :single)

#("Vancouver" "Toronto" "New York")

(query (:select 'city (:array-agg 'salary :filter (:&lt; 'salary 50000))
        :from 'employee
        :group-by 'city))

(("Vancouver" #(14420 26020)) ("New York" #(40420 40620)) ("Toronto" #(24020)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org6a1990e" class="outline-3">
<h3 id="org6a1990e">NULL and nil</h3>
<div class="outline-text-3" id="text-org6a1990e">
<p>
An empty array will be returned by postmodern as nil.
</p>

<p>
<a href="s-sql.html">Return to s-sql.html</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2018-08-11 Sat 20:58</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
